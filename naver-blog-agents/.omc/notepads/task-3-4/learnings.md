# Task 3.4 - DAG Workflow Engine 구현 학습 내용

## 구현 완료 사항

### 1. DAG Executor 구현 (`src/workflow/dag-executor.ts`)
- **Kahn's Algorithm 기반 토폴로지 정렬**
  - 진입 차수(in-degree) 계산
  - 순환 의존성 감지
  - 존재하지 않는 의존성 검증

- **레벨별 병렬 실행**
  - 같은 레벨의 노드들은 Promise.all로 병렬 실행
  - 의존성이 충족된 노드만 실행
  - 에러 발생 시 해당 노드만 실패 처리, 독립적인 노드는 계속 실행

- **에러 처리 전략**
  - 에러 발생 노드를 completed에서 제외
  - 해당 노드에 의존하는 다른 노드들은 자동으로 스킵
  - 독립적인 노드들은 계속 실행

### 2. 블로그 워크플로우 DAG 구조
```
planning ──→ research ──→ writing ──┬──→ editing ──┐
                                    │              │
                                    └──→ seo ──────┴──→ formatting
```

- editing과 seo가 병렬 실행되어 성능 최적화
- 각 단계는 명확한 의존성 정의

### 3. 테스트 커버리지
- 21개 테스트 케이스 작성 및 통과
- 토폴로지 정렬 검증
- 병렬 실행 검증
- 에러 처리 검증
- 순환 의존성 감지 검증

## 기술적 패턴

### Map 반복 처리
- TypeScript 컴파일러 호환성을 위해 `Array.from()` 사용
- `for (const [key, value] of Array.from(map))` 패턴

### 병렬 실행 전략
- 레벨별 그룹화로 최대 병렬성 확보
- Promise.all로 동시 실행
- 각 노드의 성공/실패 독립적 처리

### 타입 안전성
- WorkflowStageName 타입으로 노드 이름 제한
- DAGNode 인터페이스로 구조 강제
- 제네릭 대신 unknown으로 유연성 확보

## 성능 고려사항

### 시간 복잡도
- 토폴로지 정렬: O(V + E) - V: 노드 수, E: 간선(의존성) 수
- 레벨별 실행: O(L) - L: 레벨 수

### 병렬 실행 효과
- 블로그 워크플로우에서 editing + seo 병렬 실행
- 순차 실행 대비 약 50% 시간 절약 (2단계 → 1단계)

## 확장 가능성

### 추가 가능한 기능
1. 동적 의존성 (런타임에 의존성 결정)
2. 조건부 실행 (context 기반)
3. 우선순위 기반 스케줄링
4. 리소스 제한 (최대 동시 실행 수)
5. 재시도 로직 내장
6. 진행률 추적 및 취소 기능

### 인터페이스 안정성
- DAGNode, DAGExecutionResult 인터페이스는 확장 가능
- executor 함수 시그니처는 간단하게 유지
- 결과는 Map으로 저장하여 타입 안전성과 유연성 확보

## 코드 품질

### 문서화
- JSDoc 주석으로 모든 public 메서드 설명
- 알고리즘 설명 포함
- 사용 예제 파일 제공

### 테스트 전략
- 단위 테스트: 개별 기능 검증
- 통합 테스트: 전체 워크플로우 검증
- 경계 테스트: 빈 그래프, 단일 노드, 순환 등
- 성능 테스트: 병렬 실행 확인

## 다음 단계 통합 고려사항

### WorkflowOrchestrator와의 통합
- DAGExecutor는 실행 순서만 관리
- 실제 에이전트 호출은 Orchestrator에서 처리
- Context 전달 및 결과 매핑은 상위 레벨에서 처리

### 에러 처리 전략 통합
- DAGExecutor는 에러를 수집만 함
- 재시도, fallback 등은 Orchestrator에서 처리
- 에러 로그는 WorkflowMetadata에 기록

---

## 자금 계산 로직 추가 (Researcher Agent)

### 구현 완료 (`src/agents/researcher.ts`)

**추가된 인터페이스: FundingCalculation**
- 분양가 기반 자금 계획 계산 결과 타입
- 필드: totalPrice, ltvRatio, loanAmount, selfFunding, annualRate, monthlyInterest, summary

**추가된 함수: calculateFunding()**
- 분양가를 입력받아 자금 계획 계산
- 매개변수: priceInWon (원 단위), ltvRatio (기본 0.6), annualRate (기본 0.05)
- 계산 로직:
  - 대출 가능액 = 분양가 × LTV 비율
  - 자기자본 = 분양가 - 대출액
  - 월 이자 = 대출액 × 연금리 ÷ 12
- 억/만원 단위 변환 및 사용자 친화적 요약 문자열 생성

**ResearcherAgent.research() 메서드 수정**
- referenceData에 '평형정보' 필드가 있으면 자동으로 자금 계획 추가
- 평형정보 배열에서 최고 분양가 추출
- calculateFunding() 호출하여 자금 계획 계산
- 계산 결과를 research.facts에 추가 (reliability: 4)
- 에러 처리: 자금 계획 추가 실패는 무시 (선택적 기능)

### 기술적 패턴

**타입 안전성**
- Array<{ 최고분양가?: number }> 타입 단언으로 타입 안전성 확보
- filter의 타입 가드 `(price): price is number => ...` 사용
- 숫자 검증 포함 (typeof, > 0 체크)

**에러 처리 전략**
- try-catch로 자금 계획 추가 로직 감싸기
- 실패해도 전체 리서치 프로세스는 계속 진행
- 로깅으로 디버깅 가능하도록 처리

**데이터 검증**
- referenceData 존재 여부 확인
- '평형정보' 필드 존재 확인
- Array.isArray() 검증
- 빈 배열 체크
- 유효한 숫자 값만 필터링

### 테스트 결과

**Test 1: 5억 분양가 (기본값)**
- 대출액: 3억 (LTV 60%)
- 자기자본: 2억
- 월 이자: 125만원 (연 5%)

**Test 2: 10억 분양가 (LTV 70%, 금리 4%)**
- 대출액: 7억 (LTV 70%)
- 자기자본: 3억
- 월 이자: 233만원 (연 4%)

### 통합 효과

**리서치 품질 향상**
- 분양 관련 콘텐츠에 실질적인 자금 계획 정보 자동 추가
- 독자에게 유용한 구체적 수치 제공
- 팩트 데이터의 신뢰도 함께 표시

**확장 가능성**
- 다양한 LTV 비율 시나리오 제공 가능
- 다양한 금리 시나리오 비교 가능
- 향후 추가 금융 계산 로직 통합 용이

## SEO 전문가 프롬프트 개선 (2026-01-31)

### 추가된 기능: 키워드 선정 (전처리 모드)
- **목적**: 콘텐츠 기획 단계에서 SEO 키워드를 사전 선정
- **위치**: prompts/seo-expert.md - 응답 형식 섹션 이전에 삽입

### 선정 원칙
1. **메인 키워드 1개**: 검색량 + 경쟁도 고려, 제목 앞쪽 배치
2. **서브 키워드 2~3개**: 소제목에 사용할 연관 키워드
3. **롱테일 키워드 2개**: 구체적인 검색 의도를 담은 키워드

### 기존 기능과의 관계
- **전처리 모드**: 키워드 선정 (기획 단계)
- **후처리 모드**: SEO 최적화 (완성된 콘텐츠에 적용)
- 두 모드는 독립적으로 작동하며, 같은 에이전트(준서)가 담당
